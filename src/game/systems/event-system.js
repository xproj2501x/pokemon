/**
 * Event System
 * ===
 *
 * @module inputSystem
 */

////////////////////////////////////////////////////////////////////////////////
// Imports
////////////////////////////////////////////////////////////////////////////////
import System from '../../engine/system';

////////////////////////////////////////////////////////////////////////////////
// Definitions
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Class
////////////////////////////////////////////////////////////////////////////////
/**
 * EventSystem
 * @class
 * @implements System
 */
class EventSystem extends System {

  //////////////////////////////////////////////////////////////////////////////
  // Private Properties
  //////////////////////////////////////////////////////////////////////////////
  /**
   * @private
   * @type {MessageService}
   */
  _messageService;

  /**
   * @private
   * @type {number}
   */
  _time;

  /**
   * @private
   * @type {Array}
   */
  _events;

  /**
   * @private
   * @type {Array}
   */
  _eventTimes;

  //////////////////////////////////////////////////////////////////////////////
  // Public Properties
  //////////////////////////////////////////////////////////////////////////////

  /**
   * EventSystem
   * @constructor
   */
  constructor() {
    super();
    this._time = 0;
    this._events = [];
    this._eventTimes = [];
  }

  //////////////////////////////////////////////////////////////////////////////
  // Public Methods
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Updates the state
   */
  update() {
    this._time++;
    this.publish();
  }

  /**
   * Adds an event to the queue
   * @param {object} event
   */
  add(event) {
    const TIME = this._time + event.time;
    let index = this._events.length;

    for (let idx = 0; idx < this._eventTimes.length; idx++) {
      if (this._eventTimes[idx] > TIME) {
        index = idx;
        break;
      }
    }
    this._events.splice(index, 0, event);
    this._eventTimes.splice(index, 0, TIME);
  }

  /**
   * Gets the next event in the queue for processing.
   *
   */
  get() {
    if (!this._events.length) return null;
    this._eventTimes.shift();
    return this._events.shift();
  }

  /**
   * Publishes all events for the current time
   */
  publish() {
    while (this._eventTimes[0] === this._time) {
      const EVENT = this.get();

      if (EVENT.repeat) {
        this.add(EVENT);
      }
    }
  }

  /**
   * Clears the events and eventTimes queues.
   */
  clear() {
    this._events = [];
    this._eventTimes = [];
  }
  //////////////////////////////////////////////////////////////////////////////
  // Private Methods
  //////////////////////////////////////////////////////////////////////////////


  //////////////////////////////////////////////////////////////////////////////
  // Static Methods
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Static factory method
   * @static
   * @return {EventSystem}
   */
  static create() {
    return new EventSystem();
  }
}

////////////////////////////////////////////////////////////////////////////////
// Exports
////////////////////////////////////////////////////////////////////////////////
export default EventSystem;
