/**
 * Animation System
 * ===
 *
 * @module animationSystem
 */

////////////////////////////////////////////////////////////////////////////////
// Imports
////////////////////////////////////////////////////////////////////////////////
import System from '../../engine/system';
import {MILLISECONDS} from '../../engine/constants';
import {COMPONENT_TYPE} from '../components';

////////////////////////////////////////////////////////////////////////////////
// Definitions
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Class
////////////////////////////////////////////////////////////////////////////////
/**
 * AnimationSystem
 * @class
 * @extends System
 */
class AnimationSystem extends System {

  //////////////////////////////////////////////////////////////////////////////
  // Private Properties
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // Public Properties
  //////////////////////////////////////////////////////////////////////////////

  /**
   * AnimationSystem
   * @constructor
   */
  constructor(messageService, componentManager) {
    super(messageService, componentManager);
  }

  //////////////////////////////////////////////////////////////////////////////
  // Public Methods
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Updates the state
   */
  update(delta) {
    const COMPONENTS = this._componentManager.getComponentsOfType(COMPONENT_TYPE.ANIMATION);

    COMPONENTS.forEach((component) => {
      const STATE = component.state;
      const SPEED = (MILLISECONDS / STATE.fps);

      STATE.delta += delta;
      while (STATE.delta >= SPEED) {
        const SEQUENCE = STATE.currentSequence;

        if (STATE.currentFrame >= SEQUENCE.length - 1) {
            STATE.currentFrame += 1;
        } else {
          STATE.currentFrame = 0;
        }
        STATE.delta -= SPEED;
      }
      component.update(STATE);
    });
  }

  //////////////////////////////////////////////////////////////////////////////
  // Private Methods
  //////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////////////////////////////////////////
  // Static Methods
  //////////////////////////////////////////////////////////////////////////////
  /**
   * Static factory method.
   *
   * @static
   * @param {MessageService} messageService - The message service for the simulation.
   * @param {ComponentManager} componentManager - The component manager for the simulation.
   *
   * @return {AnimationSystem} - A new animation system instance.
   */
  static create(messageService, componentManager) {
    return new AnimationSystem(messageService, componentManager);
  }
}

////////////////////////////////////////////////////////////////////////////////
// Exports
////////////////////////////////////////////////////////////////////////////////
export default AnimationSystem;
